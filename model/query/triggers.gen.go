// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"admin/model/model"
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newTrigger(db *gorm.DB, opts ...gen.DOOption) trigger {
	_trigger := trigger{}

	_trigger.triggerDo.UseDB(db, opts...)
	_trigger.triggerDo.UseModel(&model.Trigger{})

	tableName := _trigger.triggerDo.TableName()
	_trigger.ALL = field.NewAsterisk(tableName)
	_trigger.TriggerID = field.NewInt64(tableName, "trigger_id")
	_trigger.TriggerType = field.NewString(tableName, "trigger_type")
	_trigger.TriggerConfig = field.NewString(tableName, "trigger_config")
	_trigger.TriggerLabel = field.NewString(tableName, "trigger_label")
	_trigger.UserID = field.NewInt64(tableName, "user_id")

	_trigger.fillFieldMap()

	return _trigger
}

type trigger struct {
	triggerDo

	ALL           field.Asterisk
	TriggerID     field.Int64  // 触发器主键
	TriggerType   field.String // 触发器类型
	TriggerConfig field.String // 触发器配置信息
	TriggerLabel  field.String // 触发器标签
	UserID        field.Int64  // 用户id

	fieldMap map[string]field.Expr
}

func (t trigger) Table(newTableName string) *trigger {
	t.triggerDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t trigger) As(alias string) *trigger {
	t.triggerDo.DO = *(t.triggerDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *trigger) updateTableName(table string) *trigger {
	t.ALL = field.NewAsterisk(table)
	t.TriggerID = field.NewInt64(table, "trigger_id")
	t.TriggerType = field.NewString(table, "trigger_type")
	t.TriggerConfig = field.NewString(table, "trigger_config")
	t.TriggerLabel = field.NewString(table, "trigger_label")
	t.UserID = field.NewInt64(table, "user_id")

	t.fillFieldMap()

	return t
}

func (t *trigger) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *trigger) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 5)
	t.fieldMap["trigger_id"] = t.TriggerID
	t.fieldMap["trigger_type"] = t.TriggerType
	t.fieldMap["trigger_config"] = t.TriggerConfig
	t.fieldMap["trigger_label"] = t.TriggerLabel
	t.fieldMap["user_id"] = t.UserID
}

func (t trigger) clone(db *gorm.DB) trigger {
	t.triggerDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t trigger) replaceDB(db *gorm.DB) trigger {
	t.triggerDo.ReplaceDB(db)
	return t
}

type triggerDo struct{ gen.DO }

type ITriggerDo interface {
	gen.SubQuery
	Debug() ITriggerDo
	WithContext(ctx context.Context) ITriggerDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ITriggerDo
	WriteDB() ITriggerDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ITriggerDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITriggerDo
	Not(conds ...gen.Condition) ITriggerDo
	Or(conds ...gen.Condition) ITriggerDo
	Select(conds ...field.Expr) ITriggerDo
	Where(conds ...gen.Condition) ITriggerDo
	Order(conds ...field.Expr) ITriggerDo
	Distinct(cols ...field.Expr) ITriggerDo
	Omit(cols ...field.Expr) ITriggerDo
	Join(table schema.Tabler, on ...field.Expr) ITriggerDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITriggerDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITriggerDo
	Group(cols ...field.Expr) ITriggerDo
	Having(conds ...gen.Condition) ITriggerDo
	Limit(limit int) ITriggerDo
	Offset(offset int) ITriggerDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITriggerDo
	Unscoped() ITriggerDo
	Create(values ...*model.Trigger) error
	CreateInBatches(values []*model.Trigger, batchSize int) error
	Save(values ...*model.Trigger) error
	First() (*model.Trigger, error)
	Take() (*model.Trigger, error)
	Last() (*model.Trigger, error)
	Find() ([]*model.Trigger, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Trigger, err error)
	FindInBatches(result *[]*model.Trigger, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.Trigger) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITriggerDo
	Assign(attrs ...field.AssignExpr) ITriggerDo
	Joins(fields ...field.RelationField) ITriggerDo
	Preload(fields ...field.RelationField) ITriggerDo
	FirstOrInit() (*model.Trigger, error)
	FirstOrCreate() (*model.Trigger, error)
	FindByPage(offset int, limit int) (result []*model.Trigger, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITriggerDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t triggerDo) Debug() ITriggerDo {
	return t.withDO(t.DO.Debug())
}

func (t triggerDo) WithContext(ctx context.Context) ITriggerDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t triggerDo) ReadDB() ITriggerDo {
	return t.Clauses(dbresolver.Read)
}

func (t triggerDo) WriteDB() ITriggerDo {
	return t.Clauses(dbresolver.Write)
}

func (t triggerDo) Session(config *gorm.Session) ITriggerDo {
	return t.withDO(t.DO.Session(config))
}

func (t triggerDo) Clauses(conds ...clause.Expression) ITriggerDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t triggerDo) Returning(value interface{}, columns ...string) ITriggerDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t triggerDo) Not(conds ...gen.Condition) ITriggerDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t triggerDo) Or(conds ...gen.Condition) ITriggerDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t triggerDo) Select(conds ...field.Expr) ITriggerDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t triggerDo) Where(conds ...gen.Condition) ITriggerDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t triggerDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) ITriggerDo {
	return t.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (t triggerDo) Order(conds ...field.Expr) ITriggerDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t triggerDo) Distinct(cols ...field.Expr) ITriggerDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t triggerDo) Omit(cols ...field.Expr) ITriggerDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t triggerDo) Join(table schema.Tabler, on ...field.Expr) ITriggerDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t triggerDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITriggerDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t triggerDo) RightJoin(table schema.Tabler, on ...field.Expr) ITriggerDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t triggerDo) Group(cols ...field.Expr) ITriggerDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t triggerDo) Having(conds ...gen.Condition) ITriggerDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t triggerDo) Limit(limit int) ITriggerDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t triggerDo) Offset(offset int) ITriggerDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t triggerDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITriggerDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t triggerDo) Unscoped() ITriggerDo {
	return t.withDO(t.DO.Unscoped())
}

func (t triggerDo) Create(values ...*model.Trigger) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t triggerDo) CreateInBatches(values []*model.Trigger, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t triggerDo) Save(values ...*model.Trigger) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t triggerDo) First() (*model.Trigger, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Trigger), nil
	}
}

func (t triggerDo) Take() (*model.Trigger, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Trigger), nil
	}
}

func (t triggerDo) Last() (*model.Trigger, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Trigger), nil
	}
}

func (t triggerDo) Find() ([]*model.Trigger, error) {
	result, err := t.DO.Find()
	return result.([]*model.Trigger), err
}

func (t triggerDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Trigger, err error) {
	buf := make([]*model.Trigger, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t triggerDo) FindInBatches(result *[]*model.Trigger, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t triggerDo) Attrs(attrs ...field.AssignExpr) ITriggerDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t triggerDo) Assign(attrs ...field.AssignExpr) ITriggerDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t triggerDo) Joins(fields ...field.RelationField) ITriggerDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t triggerDo) Preload(fields ...field.RelationField) ITriggerDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t triggerDo) FirstOrInit() (*model.Trigger, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.Trigger), nil
	}
}

func (t triggerDo) FirstOrCreate() (*model.Trigger, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.Trigger), nil
	}
}

func (t triggerDo) FindByPage(offset int, limit int) (result []*model.Trigger, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t triggerDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t triggerDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t triggerDo) Delete(models ...*model.Trigger) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *triggerDo) withDO(do gen.Dao) *triggerDo {
	t.DO = *do.(*gen.DO)
	return t
}
